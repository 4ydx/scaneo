package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"text/template"
)

var (
	scanStructTmpl  = template.Must(template.New("scanStructFunc").Parse(scanStructFunc))
	scanStructsTmpl = template.Must(template.New("scanStructsFunc").Parse(scanStructsFunc))

	overwrite   = flag.Bool("c", false, "Overwrite file if exists.")
	unexport    = flag.Bool("u", false, "Unexport functions")
	outFilename = flag.String("o", "scans.go", "File containg scan functions")
	packName    = flag.String("p", "current directory", "Package name")
)

func init() {
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, `usage: scaneo [options] paths...

    -c    Clobber (overwrite) file if exists. Default is append to file.

    -o    Name of output file. Default is scans.go.

    -p    Package name. Default is current directory name.

    -u    Unexport functions. Default is export all.

    -h    Display usage information and exit.`)
	}
}

func main() {
	flag.Parse()

	inputPaths := flag.Args()
	if len(inputPaths) == 0 {
		log.Println("missing input paths")
		flag.Usage()
		os.Exit(1)
	}

	if *packName == "current directory" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatalln("couldn't get working directory:", err)
		}

		*packName = filepath.Base(wd)
	}

	files, err := filenames(inputPaths)
	if err != nil {
		log.Fatalln("couldn't get filenames:", err)
	}

	structToks := make([]structToken, 0, 8)
	for _, file := range files {
		toks, err := parseCode(file)
		if err != nil {
			log.Println(`"syntax error" - parser probably`)
			log.Fatal(err)
		}

		structToks = append(structToks, toks...)
	}

	if err := writeCode(*packName, *outFilename, *unexport, structToks); err != nil {
		log.Fatalln("couldn't write code:", err)
	}
}

func filenames(paths []string) ([]string, error) {
	files := make([]string, 0, 8)

	for _, path := range paths {
		info, err := os.Stat(path)
		if err != nil {
			return nil, err
		}

		if info.IsDir() {
			filepath.Walk(path, func(wPath string, wInfo os.FileInfo, _ error) error {
				if wInfo.IsDir() {
					return nil
				} else if wInfo.Name()[0] == '.' {
					return nil
				}

				files = append(files, wPath)
				return nil
			})

			continue
		}

		files = append(files, path)
	}

	return files, nil
}

func parseCode(srcFile string) ([]structToken, error) {
	structToks := make([]structToken, 0, 8)

	fset := token.NewFileSet()
	astf, err := parser.ParseFile(fset, srcFile, nil, 0)
	if err != nil {
		return nil, err
	}

	// ast.Print(fset, astf)
	for _, dec := range astf.Decls {
		structTok := structToken{
			Fields: make([]string, 0, 8),
			Types:  make([]string, 0, 8),
		}

		genDec, isGenDec := dec.(*ast.GenDecl)
		if !isGenDec {
			continue
		}

		for _, spec := range genDec.Specs {
			typeSpec, isTypeSpec := spec.(*ast.TypeSpec)
			if !isTypeSpec {
				continue
			}

			structTok.Name = typeSpec.Name.Name

			structType, isStructType := typeSpec.Type.(*ast.StructType)
			if !isStructType {
				continue
			}

			for _, field := range structType.Fields.List {
				for _, ident := range field.Names {
					structTok.Fields = append(structTok.Fields, ident.Name)
				}

				switch fieldType := field.Type.(type) {
				case *ast.Ident:
					structTok.Types = append(structTok.Types, fieldType.Name)
				case *ast.SelectorExpr:
					ident, isIdent := fieldType.X.(*ast.Ident)
					if !isIdent {
						continue
					}

					structTok.Types = append(structTok.Types,
						fmt.Sprint(ident.Name, ".", fieldType.Sel.Name))
				case *ast.StarExpr:
					selExp, isSelector := fieldType.X.(*ast.SelectorExpr)
					if !isSelector {
						continue
					}

					ident, isIdent := selExp.X.(*ast.Ident)
					if !isIdent {
						continue
					}

					structTok.Types = append(structTok.Types,
						fmt.Sprint("*", ident.Name, ".", selExp.Sel.Name))
				case *ast.ArrayType:
					ident, isIdent := fieldType.Elt.(*ast.Ident)
					if !isIdent {
						continue
					}

					structTok.Types = append(structTok.Types,
						fmt.Sprint("[]", ident.Name))
				}

			}

			structToks = append(structToks, structTok)
		}
	}

	return structToks, nil
}

func writeCode(packName, outName string, unexport bool, toks []structToken) error {
	var outfd *os.File
	var err error
	var outExists bool

	if *overwrite {
		outfd, err = os.Create(outName)
		if err != nil {
			return err
		}
	} else {
		if _, err := os.Stat(outName); err == nil {
			outExists = true
		}

		outfd, err = os.OpenFile(outName, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
	}
	defer outfd.Close()

	if !outExists {
		fmt.Fprintln(outfd, "// DON'T EDIT *** generated by scaneo *** DON'T EDIT //")
		fmt.Fprintf(outfd, "package %s\n\n", packName)
		fmt.Fprintln(outfd, `import "database/sql"`+"\n")
	}

	data := struct {
		Tokens []structToken
		Access string
	}{
		Tokens: toks,
		Access: "S",
	}

	if unexport {
		data.Access = "s"
	}

	if err := scanStructTmpl.Execute(outfd, data); err != nil {
		return err
	}

	if err := scanStructsTmpl.Execute(outfd, data); err != nil {
		return err
	}

	return nil
}
