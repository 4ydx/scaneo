package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	structTmpl  = template.Must(template.New("scanStruct").Parse(scanStructFunc))
	structsTmpl = template.Must(template.New("scanStructs").Parse(scanStructsFunc))

	overwrite   = flag.Bool("c", false, "Overwrite file if exists.")
	unexport    = flag.Bool("u", false, "Unexport functions")
	inFiles     = flag.String("i", "", "File or directory containg structs")
	outFilename = flag.String("o", "scans.go", "File containg scan functions")
	packName    = flag.String("p", "current directory", "Package name")
)

func init() {
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, `Usage: scaneo -i filename [-o filename] [-h]

    -c    Overwrite file if exists.

    -i    Files or directory that contains struct declarations. Use quotes for
          multiple files.

    -o    Name of output file. Default is scans.go.

    -p    Package name. Default is current directory.

    -u    Unexport functions. Default is export all.

    -h    Display usage information and exit.`)
	}
}

func main() {
	flag.Parse()

	if *inFiles == "" {
		log.Println("Missing input filename.")
		flag.Usage()
		os.Exit(1)
	}

	if *packName == "current directory" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatalln("couldn't get wd:", err)
		}

		*packName = filepath.Base(wd)
	}

	files := make([]string, 0, 8)
	for _, path := range strings.Split(*inFiles, " ") {
		info, err := os.Stat(path)
		if err != nil {
			log.Fatal(err)
		}

		if info.IsDir() {
			filepath.Walk(path, func(wPath string, wInfo os.FileInfo, _ error) error {
				if wInfo.IsDir() {
					return nil
				} else if wInfo.Name()[0] == '.' {
					return nil
				} else if wInfo.Name() == *outFilename {
					return nil
				}

				files = append(files, wPath)
				return nil
			})

			continue
		}

		files = append(files, path)
	}

	structToks := make([]structToken, 0, 8)
	for _, fname := range files {
		toks, err := parseCode(fname)
		if err != nil {
			log.Println(`"syntax error" - parser probably`)
			log.Fatal(err)
		}

		structToks = append(structToks, toks...)
	}

	if err := writeCode(*packName, *unexport, structToks); err != nil {
		log.Fatalln("couldn't write code:", err)
	}
}

func parseCode(srcFile string) ([]structToken, error) {
	structToks := make([]structToken, 0, 8)

	fset := token.NewFileSet()
	astf, err := parser.ParseFile(fset, srcFile, nil, 0)
	if err != nil {
		return nil, err
	}

	// ast.Print(fset, astf)
	for _, dec := range astf.Decls {
		structTok := structToken{
			Fields: make([]string, 0, 8),
			Types:  make([]string, 0, 8),
		}

		genDec, isGenDec := dec.(*ast.GenDecl)
		if !isGenDec {
			continue
		}

		for _, spec := range genDec.Specs {
			typeSpec, isTypeSpec := spec.(*ast.TypeSpec)
			if !isTypeSpec {
				continue
			}

			structTok.Name = typeSpec.Name.Name

			structType, isStructType := typeSpec.Type.(*ast.StructType)
			if !isStructType {
				continue
			}

			for _, field := range structType.Fields.List {
				for _, ident := range field.Names {
					structTok.Fields = append(structTok.Fields, ident.Name)
				}

				switch fieldType := field.Type.(type) {
				case *ast.Ident:
					structTok.Types = append(structTok.Types, fieldType.Name)
				case *ast.SelectorExpr:
					ident, isIdent := fieldType.X.(*ast.Ident)
					if !isIdent {
						continue
					}

					structTok.Types = append(structTok.Types,
						fmt.Sprint(ident.Name, ".", fieldType.Sel.Name))
				}

			}

			structToks = append(structToks, structTok)
		}
	}

	return structToks, nil
}

func writeCode(packName string, unexport bool, toks []structToken) error {
	var outfd *os.File
	var err error
	var outExists bool

	if *overwrite {
		outfd, err = os.Create(*outFilename)
		if err != nil {
			return err
		}
	} else {
		if _, err := os.Stat(*outFilename); err == nil {
			outExists = true
		}

		outfd, err = os.OpenFile(*outFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
	}
	defer outfd.Close()

	if !outExists {
		fmt.Fprintln(outfd, "// File generated by scaneo. Don't edit.")
		fmt.Fprintf(outfd, "package %s\n\n", packName)
		fmt.Fprintln(outfd, `import "database/sql"`+"\n")
	}

	data := struct {
		Tokens []structToken
		Access string
	}{
		Tokens: toks,
		Access: "S",
	}

	if unexport {
		data.Access = "s"
	}

	if err := structTmpl.Execute(outfd, data); err != nil {
		return err
	}

	if err := structsTmpl.Execute(outfd, data); err != nil {
		return err
	}

	return nil
}
