package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const (
	all = iota
	name
	fields
)

type model struct {
	StructName string
	FieldName  []string
	FieldType  []string
}

var (
	structs = regexp.MustCompile(`(?s)type ([a-zA-Z0-9]+) struct ?\{(.*?)\}`)
	spaces  = regexp.MustCompile(`\s+`)

	structTmpl  = template.Must(template.New("scanStruct").Parse(scanStructFunc))
	structsTmpl = template.Must(template.New("scanStructs").Parse(scanStructsFunc))

	overwrite   = flag.Bool("c", false, "Overwrite file if exists.")
	unexport    = flag.Bool("u", false, "Unexport functions")
	inFiles     = flag.String("i", "", "File or directory containg structs")
	outFilename = flag.String("o", "scans.go", "File containg scan functions")
	packName    = flag.String("p", "current directory", "Package name")
)

func init() {
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, `Usage: scaneo -i filename [-o filename] [-h]

    -c    Overwrite file if exists.

    -i    Files or directory that contains struct declarations. Use quotes for
          multiple files.

    -o    Name of output file. Default is scans.go.

    -p    Package name. Default is current directory.

    -u    Unexport functions. Default is export all.

    -h    Display usage information and exit.`)
	}
}

func main() {
	flag.Parse()

	if *inFiles == "" {
		log.Println("Missing input filename.")
		flag.Usage()
		os.Exit(1)
	}

	if *packName == "current directory" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatalln("couldn't get wd:", err)
		}

		*packName = filepath.Base(wd)
	}

	files := make([]string, 0, 8)
	for _, path := range strings.Split(*inFiles, " ") {
		info, err := os.Stat(path)
		if err != nil {
			log.Fatal(err)
		}

		if info.IsDir() {
			filepath.Walk(path, func(wPath string, wInfo os.FileInfo, _ error) error {
				if wInfo.IsDir() {
					return nil
				} else if wInfo.Name()[0] == '.' {
					return nil
				} else if wInfo.Name() == *outFilename {
					return nil
				}

				files = append(files, wPath)
				return nil
			})

			continue
		}

		files = append(files, path)
	}

	modelInfo := make([]model, 0, 8)
	for _, fname := range files {
		bs, err := ioutil.ReadFile(fname)
		if err != nil {
			log.Fatalln("couldn't read input:", err)
		}

		info, err := parseStructs(bs)
		if err != nil {
			log.Fatalln("couldn't parse structs:", err)
		}

		modelInfo = append(modelInfo, info...)
	}

	if err := writeCode(*packName, *unexport, modelInfo); err != nil {
		log.Fatalln("couldn't write code:", err)
	}
}

func writeCode(packName string, unexport bool, modInfo []model) error {
	var outfd *os.File
	var err error
	var outExists bool

	if *overwrite {
		outfd, err = os.Create(*outFilename)
		if err != nil {
			return err
		}
	} else {
		if _, err := os.Stat(*outFilename); err == nil {
			outExists = true
		}

		outfd, err = os.OpenFile(*outFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
	}
	defer outfd.Close()

	if !outExists {
		fmt.Fprintln(outfd, "// File generated by scaneo. Don't edit.")
		fmt.Fprintf(outfd, "package %s\n\n", packName)
		fmt.Fprintln(outfd, `import "database/sql"`+"\n")
	}

	data := struct {
		Models []model
		Access string
	}{
		Models: modInfo,
		Access: "S",
	}

	if unexport {
		data.Access = "s"
	}

	if err := structTmpl.Execute(outfd, data); err != nil {
		return err
	}

	if err := structsTmpl.Execute(outfd, data); err != nil {
		return err
	}

	return nil
}

func parseStructs(code []byte) ([]model, error) {
	models := make([]model, 0, 8)

	for _, dec := range structs.FindAllSubmatch(code, -1) {
		m := model{
			StructName: string(dec[name]),
		}

		fs := spaces.ReplaceAllString(string(dec[fields]), " ")
		fs = fs[1 : len(fs)-1]

		nameValues := strings.Split(fs, " ")

		if len(nameValues)%2 != 0 {
			return nil, errors.New("Malformed struct declaration.")
		}

		for i, elem := range nameValues {
			if i%2 == 0 {
				m.FieldName = append(m.FieldName, elem)
			} else {
				m.FieldType = append(m.FieldType, elem)
			}
		}

		models = append(models, m)
	}

	return models, nil
}
