package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const (
	all = iota
	name
	fields
)

type model struct {
	StructName string
	FieldName  []string
	FieldType  []string
}

var (
	structs = regexp.MustCompile(`(?s)type ([a-zA-Z0-9]+) struct ?\{(.*?)\}`)
	spaces  = regexp.MustCompile(`\s+`)

	structTmpl  = template.Must(template.New("scanStruct").Parse(scanStructFunc))
	structsTmpl = template.Must(template.New("scanStructs").Parse(scanStructsFunc))

	inFilename  = flag.String("i", "", "File containg structs")
	outFilename = flag.String("o", "scans.go", "File containg scan functions")
	packName    = flag.String("p", "current directory", "Package name")
)

func init() {
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, `Usage: scaneo -i filename [-o filename] [-h]

    -i    File that contains struct declarations.

    -o    Name of output file. Default is scans.go.

    -p    Package name. Default is current directory.

    -h    Display usage information and exit.`)
	}
}

func main() {
	flag.Parse()

	if *inFilename == "" {
		log.Println("Missing input filename.")
		flag.Usage()
		os.Exit(1)
	}

	if *packName == "current directory" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}

		*packName = filepath.Base(wd)
	}

	bs, err := ioutil.ReadFile(*inFilename)
	if err != nil {
		log.Fatal(err)
	}

	modInfo, err := parseStructs(bs)
	if err != nil {
		log.Fatal(err)
	}

	if err := writeCode(*packName, modInfo); err != nil {
		log.Fatal(err)
	}
}

func writeCode(packName string, modInfo []model) error {
	outfd, err := os.Create(*outFilename)
	if err != nil {
		return err
	}

	fmt.Fprintln(outfd, "// File generated by scaneo. Don't edit.")
	fmt.Fprintf(outfd, "package %s\n\n", packName)
	fmt.Fprintln(outfd, `import "database/sql"`+"\n")

	if err := structTmpl.Execute(outfd, modInfo); err != nil {
		return err
	}

	if err := structsTmpl.Execute(outfd, modInfo); err != nil {
		return err
	}

	return nil
}

func parseStructs(code []byte) ([]model, error) {
	models := make([]model, 0, 8)

	for _, dec := range structs.FindAllSubmatch(code, -1) {
		m := model{
			StructName: string(dec[name]),
		}

		fs := spaces.ReplaceAllString(string(dec[fields]), " ")
		fs = fs[1 : len(fs)-1]

		nameValues := strings.Split(fs, " ")

		if len(nameValues)%2 != 0 {
			return nil, errors.New("Malformed struct declaration.")
		}

		for i, elem := range nameValues {
			if i%2 == 0 {
				m.FieldName = append(m.FieldName, elem)
			} else {
				m.FieldType = append(m.FieldType, elem)
			}
		}

		models = append(models, m)
	}

	return models, nil
}
