# scaneo

[![Build Status](https://drone.io/github.com/variadico/scaneo/status.png)](https://drone.io/github.com/variadico/scaneo/latest)

Generate code to convert `*sql.Row` and `*sql.Rows` into arbitrary structs.
Works with any database driver. Don't have to worry about database columns
and struct names matching. No reflection.

For people who know SQL and only need `sql.QueryRow` and `sql.Query`.

## Installation

```
go get github.com/variadico/scaneo
```

## Usage

```
usage: scaneo [options] paths...

    -c    Clobber (overwrite) file if exists. Default is append to file.

    -o    Name of output file. Default is scans.go.

    -p    Package name. Default is current directory name.

    -u    Unexport functions. Default is export all.

    -h    Display usage information and exit.
```

## Examples

Let's say you have a file called `tables.go` that looks like this.

```
package models

import "time"

type Post struct {
	ID        int
	URL       string
	Created   time.Time
	Modified  time.Time
	Published pq.NullTime
	Draft     bool
	Title     string
	Body      string
}
```

If you run `scaneo tables.go`, this will generate a new file called
`scans.go`. `scans.go` will contain a pair of functions for each struct in
`tables.go`. In this example, `ScanPost` and `ScanPosts`. The singular version
will return a single struct, while the plural version will return a slice of
structs. This follows the naming pattern of `sql.Row` and `sql.Rows`.
`scans.go` will look like the following.

```
// DON'T EDIT *** generated by scaneo *** DON'T EDIT //
package testdata

import "database/sql"

func ScanPost(r *sql.Row) (Post, error) {
	var s Post

	if err := r.Scan(
		&s.ID,
		&s.URL,
		&s.Created,
		&s.Modified,
		&s.Published,
		&s.Draft,
		&s.Title,
		&s.Body,
	); err != nil {
		return Post{}, err
	}

	return s, nil
}

func ScanPosts(rs *sql.Rows) ([]Post, error) {
	structs := make([]Post, 0, 16)

	var err error
	for rs.Next() {
		var s Post

		if err = rs.Scan(
			&s.ID,
			&s.URL,
			&s.Created,
			&s.Modified,
			&s.Published,
			&s.Draft,
			&s.Title,
			&s.Body,
		); err != nil {
			return nil, err
		}

		structs = append(structs, s)
	}

	return structs, nil
}
```

Now you can just call those functions from other parts of your code.

```
func serveHome(resp http.ResponseWriter, req *http.Request) {
	rows, err := db.Query("select * from post")
	if err != nil {
		log.Println(err)
		return
	}

	posts, err := models.ScanPosts(rows) // ScanPosts was auto-generated!
	if err != nil {
		log.Println(err)
	}

	// ... send posts to template or whatever...
}
```

### Go Generate

You can integrate `scaneo` with `go generate` by adding the generate comment to
the beginning of `tables.go`. `$GOFILE` is the name of the current
file, in this case, `tables.go`.

```
//go:generate scaneo -c $GOFILE

package models
... rest of code...
```

Then just call `go generate` from within the package and `scans.go` will be
created.

## FAQ
**Why did you write this instead of using sqlx, modl, gorm, gorp, etc?**

1. Didn't know which one I should learn. Already knew `database/sql`.
2. All I wanted was structs from the database.
3. You still write SQL and declare structs with sqlx, so I didn't get the
point. Others felt unnecessary and way more complex for my small project.
4. I can SQL.

**Do my table columns have to match my struct field names?**

Nope. The names don't actually matter at all. However, what *does* matter is
the order in which you declare the types in your struct. *That* has to match
the database table. So if your table looks like this:

```
 user_id | first_name | last_name
---------+------------+-----------
       1 | Brian      | Cruz
```

then, your struct field names **must** follow the same order.

```
type User struct {
	ID        int
	FirstName string
	LastName  string
}
```
